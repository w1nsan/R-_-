#==================
#要在R script中储存中文，最好在global option的code--saving中选择UTF8
#==================
#2.3向量

#创建向量;函数 c()

myvec<- c(1,2,3,1:3)
myvec2<-c(1,2,myvec)
myvec3<-c(0.3,myvec,myvec2)

# 向量相关函数；
## 冒号
1:27 #创建间隔为1的递增序列；

foo<- 2.7
foot<- foo:(2.6*1.3+6) #冒号后可以是一个算术

## 序列函数 seq()
seq(from=1,to=55,by=2.1) #通过设置3个参数来生成特定数值型向量序列
seq(from=1,to=55,length.out = 22) #通过更改向量长度参数，来生成起始数字固定的不等长向量；
seq(from=55,to=1,by=-2) # 生成递减序列

## 重复函数 rep()

rep(x=1,times=4) #数字1，重复4次
rep(1,4) #简写
rep(x=1:4,times=2) #将x重复两次
rep(x=1:4,each=2) # 在重复x时，将x中每个元素重复2次
rep(x=1:4,times=2,each=3) #将x重复2次，每次重复时，x里的每个元素重复3次。
com<- c(3,0.1,rep(x=1:4,times=foo),seq(from=-2,to=1,length.out = foo+1)) 
#次数也可以用变量表示，不是整数的自动取整数部分（not 四舍五入）

## 排序函数 sort()

sort(x=c(2.5,1.2,-2,-3,0.88),decreasing = TRUE) #对特定向量x进行排序，降序排列
sort(x=c(2.5,1.2,-2,-3,0.88)) #默认升序
foo<- seq(from=3.4,to=83,length.out = 8) # 1.创建序列
bar<-sort(foo,decreasing = TRUE) # 2.排序
bar

sort(x=c(foo,bar),decreasing = TRUE)

## 长度函数 length()

length(foo) #计算foo向量里有多少个元素
length(bar)
com<- c(3,0.1,rep(x=1:4,times=2),seq(from=-2,to=1,length.out = 2+1))
length(com) # 如果所包含的元素要通过其他函数计算得到，length函数将返回这些内部函数执行之后的元素个数。

# 2.3.3 子集和元素的提取 （索引法）

## 提取向量元素：索引法 & 逻辑标记法

## 假设有一个向量 myvec，它的元素数量是 length(myvec)，里面每个元素按顺序是第1,第2...直到第length(myvec)个。

myvec<- c(5,-2.3,4,4,4,6,8,10,124,-8) #创建向量
length(myvec) #向量长度（元素数量）
myvec[1] #用中括号取第一个元素
myvec[length(myvec)] # 取整个向量的最后一个元素（用向量长度表示最后一个向量的位置。）
myvec.len<- length(myvec)# 将向量长度赋值到新变量
myvec[myvec.len-1] #取倒数第二个元素

## 删除索引位置的元素
myvec[-1] #负索引删除向量中的元素。删除第n个元素就是[-n]
myvec[-c(1,3,5)] #一个索引向量中不能正负指标混用
## 提取多个元素（子集）
myvec[c(1,3,5)] #用c函数
myvec[1:3] #用冒号

## 用rep()函数来重复同一个索引
indexes<- c(4,rep(x=2,times=3),1,1,3:1)
myvec[indexes]

## 修改向量中特定索引元素的内容

bar<- c(3,-2,1,5,-6,7,-8,9,10) #一个向量
bar[1]<- 0.3  #用中括号指定你希望修改的元素，然后赋予新的值
bar

bar[c(2,3,4,6)]<-c(0.1,0.2,0.3,0.4) #将不同的元素赋予不同的新值
bar[1:4]<- 66.6  #将不同的元素赋予同一个新值

# 2.3.4 面向向量的操作

# 两个向量的运算
foo<- 5.5:0.5
foo-c(2,4,6,8,10,12) # 等长向量操作，元素位置一一对应

bar<-c(1,-1)
foo*bar # 不等长向量操作，循环操作。

# 对任意长度向量中的每个元素进行相同操作
qux<-3
foo+qux # 简明代码
foo+rep(x=3,times=length(foo))# 复杂代码

#对多个元素进行不等长替换（会将短的向量循环）
foo[c(1,3,5,7)]<-c(99,-99) 

# 对向量中所有元素进行基础统计
foo
sum(foo) #统计总和
prod(foo) #计算连乘积（所有元素相乘）

#=============================
# 3.0.0矩阵和数组
#=============================

# 3.1 定义一个矩阵

## 创建一个矩阵，使用matrix()函数
myma<- matrix(data=c(-3,2,896,0.17),nrow=2,ncol=2) 
#创建一个两行两列的矩阵，并且默认按列填充。
#如果不提供行nrow和列ncol的参数，就会默认每行一个元素。
myma

# 3.1.1 矩阵填充方式
matrix(data=c(1,2,3,4,5,6),nrow = 3,ncol = 2,byrow = FALSE) #（默认）按列填充
matrix(data=c(1,2,3,4,5,6),nrow = 3,ncol = 2,byrow = TRUE) #按行填充

# 3.1.2 合并行 & 合并列
## 将两个等长的向量合并列row
c1<-c(1:5)
c2<-c(5:9)
rbind(c1,c2) #将两个向量按两行来合并，生成一个两行的矩阵；

## 将等长的向量合并行col
cbind(1:3,2:4,3:5)  #将三个向量按三列来合并，生成一个3列的矩阵；

# 3.1.3 矩阵的维度

#统计矩阵向量的相关数值
mymat<- rbind(c(1,3,4),5:3,c(100,20,90),11:13)
dim(mymat) #查看矩阵维度（行列数）
nrow(mymat) #查看行
ncol(mymat) #查看列
dim(mymat)[2]#查看维度的第二个元素，也就是列数。

# 3.2构造矩阵子集

maA<- matrix(c(0.3,4.5,55.3,91,0.1,105.5,-4.2,8.2,27.9),nrow=3,ncol = 3)
maA
maA[3,2] # 提取第三行第二列的元素
maA[2,] # 提取第二行
maA[,c(2,3)] # 提取第2,3列

#当矩阵是方阵时（行数与列数相同）可以用diag()来提取对角线元素；
diag(maA) #提取矩阵中对角线的元素；

#3.2.2 省略和改写

maA[,-2]#删除矩阵的第二列
maA[-1,3:2] #删除第一行，并且按顺序取出第三列和第二列

## 赋予矩阵元素新值得操作与之前的一致：先指定位置然后用“<”赋予新的数值；

maB<-maA #先创建一个副本
maB
maB[2,]<-1:3 #对第二行赋予等长的新值123
maB[c(1,3),2]<- 900 #对第1,3行的第二个数赋予一样的新值 900 
maB[,3]<-maB[3,] # 将第三行的值赋予给第三列（等长）

## 用两个元素长度的向量对矩阵中4个元素进行改写
maB[c(1,3),c(1,3)]<- c(-7,7)
# -7和7会按顺序交替替换矩阵中相应索引位置的元素
# 依旧是按列column来填充，顺序是 [1,1],[3,1],[1,3],[3,3]

diag(maB)<-0 #对对角线进行改写不需要索引

#==========
#批量修改函数 paste0()和 paste()
#==========

paste0(a,b) # 将a加到b的前面，成为"ab"
paste(a,b) # 功能一样，但是ab之间会有空格隔开即："a b" 

#更长的例子 
nth<-paste0(1:12,c("st","nd","rd",rep("th",9))) #将1~12数字分别跟后面向量里的元素搭配（一一对应,如果元素不匹配那就循环少的那个）
nth<-paste(1:12,c("st","nd","rd",rep("th",9))) #结果一样但是两个元素结合时中间多出一个空格

#===
#3.3.1 矩阵的转换
#===
A<- rbind(c(2,5,2),c(6,1,4)) #构建一个2*3的矩阵
t(A) #转置成一个3*2的矩阵

#===
#3.3.2 单位矩阵
#===
#单位矩阵一般用Im表示，定义是对角线上数字为1，其余数字为0的mxm矩阵。
#可以使用 diag()来构建单位矩阵
AI<- diag(x=3) #构建一个对角线是3个元素的单位矩阵
AI

#===
#3.3.3 矩阵的数乘
#===
#以矩阵A为例,用运算符“*”实现矩阵的数乘；
A*2

#===
#3.3.4 矩阵的加减
#===

#同阶的矩阵之间可以进行直接的加减
A*2+A
A*3-A*2

#===
#3.3.4 矩阵乘法
#===
# 特指两个矩阵之间相乘
# 矩阵相乘的值：矩阵A的第i行里每个元素分别与矩阵B第j列的每个元素对应相乘再相加
# 需要A矩阵的行数=B矩阵的列数 才可以相乘。
# AB的结果与BA的结果是不一样的。
# 用 “%*%” 作为运算符
#===
#3.3.5 逆矩阵
#===
#求矩阵AA的-1次方
solve(AA)


# 3.4 多维数组

# 数组的维度 （行，列，层）

# 数组的创建
## 使用函数 array()

AR<- array(data=1:24,dim=c(3,4,2))

# 数组子集的提取和替换
AR[2,,2] #提取第二层矩阵中的第二行数
AR[2,C(1,3),2]
